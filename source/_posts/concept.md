---
title: concept
tags: other
date: 2019-10-28
---

### cookie & session

> 引用: [ 轩辕志远 - 知乎](https://www.zhihu.com/people/xuanyuanzhiyuan/activities)

1. 由于 HTTP 协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是 Session.典型的场景比如购物车，当你点击下单按钮时，由于 HTTP 协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的 Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个 Session 是保存在服务端的，有一个唯一标识。在服务端保存 Session 的方法很多，内存、数据库、文件都有。集群的时候也要考虑 Session 的转移，在大型的网站，一般会有专门的 Session 服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如 Memcached 之类的来放 Session。
2. 思考一下服务端如何识别特定的客户？这个时候 Cookie 就登场了。每次 HTTP 请求的时候，客户端都会发送相应的 Cookie 信息到服务端。实际上大多数的应用都是用 Cookie 来实现 Session 跟踪的，第一次创建 Session 的时候，服务端会在 HTTP 协议中告诉客户端，需要在 Cookie 里面记录一个 Session ID，以后每次请求把这个会话 ID 发送到服务器，我就知道你是谁了。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做 URL 重写的技术来进行会话跟踪，即每次 HTTP 交互，URL 后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。
3. Cookie 其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到 Cookie 里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是 Cookie 名称的由来，给用户的一点甜头。
   所以，
4. 总结一下：
   Session 是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；
   Cookie 是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现 Session 的一种方式。

### HTML 实体

在 HTML 中，某些字符是预留的。

在 HTML 中不能使用小于号（<）和大于号（>），这是因为浏览器会误认为它们是标签。

如果希望正确地显示预留字符，我们必须在 HTML 源代码中使用字符实体（character entities）。

字符实体类似这样：` &entity_name;`` 或者 `&#entity_number;``

如需显示小于号，我们必须这样写：&lt;`或 &#60;`

**提示：**使用实体名而不是数字的好处是，名称易于记忆。不过坏处是，浏览器也许并不支持所有实体名称（对实体数字的支持却很好）。

**HTML 中有用的字符实体**

**注释：**实体名称对大小写敏感！

| 显示结果 | 描述              | 实体名称             | 实体编号  |
| :------- | :---------------- | :------------------- | :-------- |
|          | 空格              | `&nbsp;`             | `&#160;`  |
| <        | 小于号            | `&lt;`               | `&#60;`   |
| >        | 大于号            | `&gt;`               | `&#62;`   |
| &        | 和号              | `&amp;`              | `&#38;`   |
| "        | 引号              | `&quot;`             | `&#34;`   |
| '        | 撇号              | `&apos;` (IE 不支持) | `&#39;`   |
| ￠       | 分（cent）        | `&cent;`             | `&#162;`  |
| £        | 镑（pound）       | `&pound;`            | `&#163;`  |
| ¥        | 元（yen）         | `&yen;`              | `&#165;`  |
| €        | 欧元（euro）      | `&euro;`             | `&#8364;` |
| §        | 小节              | `&sect;`             | `&#167;`  |
| ©        | 版权（copyright） | `&copy;`             | `&#169;`  |
| ®        | 注册商标          | `&reg;`              | `&#174;`  |
| ™        | 商标              | `&trade;`            | `&#8482;` |
| ×        | 乘号              | `&times;`            | `&#215;`  |
| ÷        | 除号              | `&divide;`           | `&#247;`  |

### debug

step into：单步执行，遇到子函数就进入并且继续单步执行（简而言之，进入子函数）；

step over：在单步执行时，在函数内遇到子函数时不会进入子函数内单步执行，而是将子函数整个执行完再停止，也就是把子函数整个作为一步。

step out：当单步执行到子函数内时，用 step out 就可以执行完子函数余下部分，并返回到上一层函数。

### 引用透明性

> 引用:

初学程序设计时，比较容易混淆的两个概念是数学函数（math function）和程序中使用的函数。

在数学函数中 y=f(x)y=f(x)，一个输入值有固定的输出值。例如，无论计算多少次，sinπsin⁡π 的结果总是 0。如果 f(x)=x/2f(x)=x/2，那么 f(10)f(10) 无论计算 100 次还是 1000 次，其结果都是 5.

程序设计中的函数却不具备这种稳定的特性，因为函数的执行不仅依赖于输入值，而且会受到全局变量，输入文件，类的成员变量等诸多因素的影响。如下：

```java
int counter = 0;
int count(){
    return ++counter;
}
```

此函数输入没有输入值，但每次都返回不同的结果。当然，就像数学函数那样，程序中函数还可以设计成“对同一输入值每次都返回相同结果”的形式。

函数的返回值只依赖于其输入值，这种特性就称为引用透明性（referential transparency）
